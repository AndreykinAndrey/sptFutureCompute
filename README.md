**Задание:**
Реализовать потокобезопасный класс содержащий метод Future<V> compute(K k, Function<K, V> f),
который возвращает значение Future<V> по ключу K в соответствии с заданной функцией f вычисляющей
значение V по ключу K.
В случае, если значение K уже встречалось, то значение V не должно вычисляться повторно, а должно браться из кеша.

**Комментарии к реализации**
В качестве кэша использована библиотека caffeine.
В принципе, она умеет все, что требуется в задании. Кроме потокобезопасного класса.
Так как в задании явно не требовалось, кэш руками делать не стал. Потому что хорошие реализации уже есть и сделать руками лучше врядли получится:)

Потокобезопасный класс реализован как синглтон с ленивой инициализацией.

Пример реализован в AsyncComputerImpl. 
Тут используется кэш с асинхронным заполнением. Поэтому в методе compute достаточно просто вызывать стандартный метод поиска в кэше caffeine.   

В ComputeImpl чуть-чуть по-другому сделан метод compute. Тут используется кэш с синхронным заполнением.
Получается такая эмуляция требований задания. На самом деле, под капотом синхронный кэш исопльзует тоже CompletableFuture. 

Все это до какой-то степени можно проверить, выполнив тесты. 
Там, конечно, каша. Стоит это признать:)
 

